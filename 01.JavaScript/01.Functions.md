# JavaScript Functions and Objects

## 1. Ways to Write Functions

In JavaScript, functions can be written in several ways:

### Function Declaration
```javascript
function greet() {
  console.log("Hello!");
}
```

### Function Expression
```javascript
const greet = function() {
  console.log("Hello!");
};
```

### Arrow Function Expression
```javascript
const greet = () => {
  console.log("Hello!");
};
```

### Named Function Expression
```javascript
const greet = function greetFunction() {
  console.log("Hello!");
};
```

### Immediately Invoked Function Expression (IIFE)
```javascript
(function() {
  console.log("Hello!");
})();
```

---

## 2. Function Parameters and Arguments

### Parameters vs Arguments
- **Parameters** are the placeholders (variables) listed in the function definition. They act as local variables within the function.
- **Arguments** are the actual values passed to the function when it is called. These values are assigned to the parameters.

Example:
```javascript
function add(a, b) { // a and b are parameters
  return a + b;
}

add(2, 3); // 2 and 3 are arguments
```

### Flexible Argument Handling
JavaScript functions can be called with any number of arguments, regardless of the number of parameters defined. This is due to JavaScript's dynamic nature.

- If fewer arguments are passed than parameters, the extra parameters are `undefined`.
- If more arguments are passed, the extra ones are ignored unless accessed via the `arguments` object.

Example:
```javascript
function sum(a, b, c) {
  console.log(a, b, c); // 1, 2, undefined
}

sum(1, 2); // Only two arguments passed
```

### Default Parameters
Default parameters allow you to set default values for parameters if no argument is provided or if `undefined` is passed.

```javascript
function greet(name = "Guest", age = 18) {
  console.log(`Hello, ${name}! You are ${age} years old.`);
}

greet(); // Hello, Guest! You are 18 years old.
greet("Alice"); // Hello, Alice! You are 18 years old.
greet("Bob", 25); // Hello, Bob! You are 25 years old.
greet("Charlie", undefined); // Hello, Charlie! You are 18 years old.
```

---

---

## 4. Scope of Function

- **Global Scope:** Variables declared outside any function are global.
- **Function Scope:** Variables declared inside a function are local to that function.
- **Block Scope:** Variables declared with `let` or `const` inside blocks `{}` are block-scoped.

Example:
```javascript
let globalVar = "I am global";

function testScope() {
  let localVar = "I am local";
  if(true) {
    let blockVar = "I am block scoped";
    console.log(blockVar); // accessible here
  }
  // console.log(blockVar); // Error: blockVar is not defined
  console.log(localVar); // accessible here
}

testScope();
console.log(globalVar); // accessible here
// console.log(localVar); // Error: localVar is not defined
```

---

## 5. Hoisting in Detail with Execution Context and Example

### What is Hoisting?

Hoisting is JavaScript's default behavior of moving declarations to the top of the current scope (script or function) during the compilation phase.

- Variable declarations (`var`) and function declarations are hoisted.
- Variables declared with `let` and `const` are hoisted but not initialized (Temporal Dead Zone).
- Function expressions and arrow functions are not hoisted.

### Execution Context

- **Creation Phase:** Memory is allocated for variables and functions.
- **Execution Phase:** Code is executed line by line.

### Example of Hoisting with Function Declaration
```javascript
sayHello();

function sayHello() {
  console.log("Hello from hoisted function!");
}
```
Output:
```
Hello from hoisted function!
```

### Example of Hoisting with Variable Declaration
```javascript
console.log(a); // undefined
var a = 5;
console.log(a); // 5
```

### Example of Temporal Dead Zone with `let` and `const`
```javascript
console.log(b); // ReferenceError: Cannot access 'b' before initialization
let b = 10;
```

### Example of Function Expression Hoisting
```javascript
sayHi(); // TypeError: sayHi is not a function

var sayHi = function() {
  console.log("Hi!");
};
```

---

## 6. The `this` Keyword in Detail

### What is `this`?

The `this` keyword in JavaScript refers to the object that is executing the current function. Its value depends on how the function is called, not where it's defined. Understanding `this` is crucial for working with objects, classes, and event handlers.

### `this` in Different Contexts

#### 1. Global Context
In the global scope (outside any function), `this` refers to the global object (`window` in browsers, `global` in Node.js).

```javascript
console.log(this); // In browser: Window object
```

#### 2. Function Context (Non-Strict Mode)
In a regular function, `this` refers to the global object.

```javascript
function showThis() {
  console.log(this);
}

showThis(); // Window object (in browser)
```

#### 3. Function Context (Strict Mode)
In strict mode, `this` is `undefined` in a regular function.

```javascript
"use strict";

function showThis() {
  console.log(this); // undefined
}

showThis();
```

#### 4. Method Context
When a function is called as a method of an object, `this` refers to the object the method is called on.

```javascript
const person = {
  name: "John",
  greet: function() {
    console.log("Hello, " + this.name);
  }
};

person.greet(); // Hello, John
```

#### 5. Constructor Context
In a constructor function, `this` refers to the newly created instance.

```javascript
function Person(name) {
  this.name = name;
  this.greet = function() {
    console.log("Hi, I'm " + this.name);
  };
}

const john = new Person("John");
john.greet(); // Hi, I'm John
```

#### 6. Arrow Functions
Arrow functions do not have their own `this`. They inherit `this` from the enclosing lexical scope.

```javascript
const person = {
  name: "John",
  greet: function() {
    const arrowGreet = () => {
      console.log("Hello, " + this.name);
    };
    arrowGreet();
  }
};

person.greet(); // Hello, John
```

#### 7. Event Handlers
In event handlers, `this` refers to the element that triggered the event.

```javascript
// In HTML: <button id="myButton">Click me</button>

const button = document.getElementById("myButton");
button.addEventListener("click", function() {
  console.log(this); // The button element
});
```

### Common Pitfalls and Solutions

#### Losing `this` Context
When passing object methods as callbacks, the `this` context can be lost.

```javascript
const person = {
  name: "John",
  greet: function() {
    console.log("Hello, " + this.name);
  }
};

setTimeout(person.greet, 1000); // Hello, undefined (this is Window)
```

**Solutions:**
1. Use `bind()`:
```javascript
setTimeout(person.greet.bind(person), 1000); // Hello, John
```

2. Use arrow function:
```javascript
setTimeout(() => person.greet(), 1000); // Hello, John
```

3. Store `this` in a variable:
```javascript
const person = {
  name: "John",
  greet: function() {
    const self = this;
    setTimeout(function() {
      console.log("Hello, " + self.name);
    }, 1000);
  }
};
```

### Explicit `this` Binding

#### `call()` Method
Calls a function with a given `this` value and arguments.

```javascript
function greet(greeting) {
  console.log(greeting + ", " + this.name);
}

const person = { name: "John" };
greet.call(person, "Hello"); // Hello, John
```

#### `apply()` Method
Similar to `call()`, but arguments are passed as an array.

```javascript
greet.apply(person, ["Hi"]); // Hi, John
```

#### `bind()` Method
Returns a new function with `this` bound to a specific object.

```javascript
const boundGreet = greet.bind(person);
boundGreet("Hey"); // Hey, John
```

### Important Notes
- `this` is determined at runtime, not at definition time.
- Arrow functions are particularly useful for maintaining lexical scope.
- Always be cautious when using `this` in callbacks or event handlers.
- In strict mode, `this` in global functions is `undefined` instead of the global object.

---

## 7. Objects in Detail with Examples

### What is an Object?

An object is a collection of key-value pairs. Keys are strings (or Symbols), and values can be any data type including other objects or functions.

### Creating Objects

#### Object Literal
```javascript
const person = {
  name: "John",
  age: 30,
  greet: function() {
    console.log("Hello, " + this.name);
  }
};
```

#### Using `new Object()`
```javascript
const person = new Object();
person.name = "John";
person.age = 30;
person.greet = function() {
  console.log("Hello, " + this.name);
};
```

### Accessing Object Properties
```javascript
console.log(person.name); // Dot notation
console.log(person["age"]); // Bracket notation
```

### Adding and Deleting Properties
```javascript
person.job = "Developer"; // Add
delete person.age; // Delete
```

### Methods in Objects
Functions inside objects are called methods.
```javascript
person.greet(); // Hello, John
```

### Nested Objects
```javascript
const employee = {
  name: "Alice",
  address: {
    city: "New York",
    zip: 10001
  }
};
console.log(employee.address.city); // New York
```

### Object Constructor Function
```javascript
function Person(name, age) {
  this.name = name;
  this.age = age;
  this.greet = function() {
    console.log("Hi, I'm " + this.name);
  };
}

const p1 = new Person("Bob", 25);
p1.greet(); // Hi, I'm Bob
```

### ES6 Classes (Syntactic Sugar)
```javascript
class Person {
  constructor(name, age) {
    this.name = name;
    this.age = age;
  }
  greet() {
    console.log(`Hello, my name is ${this.name}`);
  }
}

const p2 = new Person("Carol", 28);
p2.greet(); // Hello, my name is Carol
```

---

